import { getProblemPythonCode } from './problemPythonCodes'

const GUIDES = {
    '1': {
        approach: '哈希表一次遍历',
        target: '在数组中找到和为 target 的两个下标。',
        brute: '双重循环枚举所有 (i, j)，判断 nums[i] + nums[j] 是否等于 target。',
        breakthrough: '遍历到 x 时，只要之前见过 target - x，就立刻得到答案。',
        steps: [
            '建立 map：数字值 -> 下标。',
            '从左到右遍历 i，先查 map 是否存在 target - nums[i]。',
            '若存在直接返回 [map[target - nums[i]], i]，否则记录 map[nums[i]] = i。',
            '注意顺序是先查后存，避免重复使用同一元素。',
        ],
        time: 'O(n)',
        space: 'O(n)',
        pitfalls: ['先存后查会误用当前元素。', '数组有重复值时，map 要保存最新或最早下标并保证逻辑一致。'],
        pitch: '这题核心是“查补数”。我用哈希表把双循环降到一次遍历，时间 O(n)，空间 O(n)。',
    },
    '49': {
        approach: '哈希分组（排序签名）',
        target: '把互为字母异位词的字符串分到同一组。',
        brute: '两两比较字符串是否互为异位词，做连通分组。',
        breakthrough: '异位词排序后字符串相同，可作为稳定分组 key。',
        steps: [
            '遍历每个单词 s，把 s 排序得到 signature。',
            '用 map[signature] 存放同组单词列表。',
            '遍历结束后返回 map 的所有 value。',
            '若担心排序常数大，可改为 26 计数签名。',
        ],
        time: 'O(n * k log k)',
        space: 'O(n * k)',
        pitfalls: ['key 需要稳定且可哈希。', '注意空字符串也要正确分组。'],
        pitch: '我把“是否异位词”转成“签名是否相同”，签名用排序串，一次遍历分桶即可。',
    },
    '128': {
        approach: '哈希集合找连续序列起点',
        target: '返回最长连续整数序列长度（不要求原数组连续）。',
        brute: '排序后线性扫描统计连续段长度。',
        breakthrough: '只从“序列起点”扩展：若 num-1 不在集合中，num 才可能是起点。',
        steps: [
            '把所有数字放入 set。',
            '遍历每个 num：仅当 num-1 不在 set 时才向右扩展。',
            '连续检查 num+1, num+2... 并更新最大长度。',
            '每个数最多被扩展访问一次，整体 O(n)。',
        ],
        time: 'O(n)',
        space: 'O(n)',
        pitfalls: ['不要对每个数都无脑向右扩展，否则退化。', '有重复值时 set 会去重，逻辑不受影响。'],
        pitch: '关键是“只从起点扩展”，避免重复扫描，时间可做到线性。',
    },
    '238': {
        approach: '前缀积 + 后缀积',
        target: '输出 answer[i] = 除 nums[i] 外其余元素乘积，且不使用除法。',
        brute: '对每个 i 再遍历一遍数组求乘积。',
        breakthrough: 'answer[i] = 左侧乘积 * 右侧乘积，可分两趟计算。',
        steps: [
            '第一趟从左到右，answer[i] 先放“左侧前缀积”。',
            '第二趟从右到左，维护 suffix，把 answer[i] *= suffix。',
            '每次更新 suffix *= nums[i]。',
            '最终 answer 即目标数组。',
        ],
        time: 'O(n)',
        space: 'O(1) 额外空间（不计输出数组）',
        pitfalls: ['第二趟别覆盖前缀信息。', '注意 0 的情况该方法天然支持。'],
        pitch: '我把每个位置拆成左右两部分乘积，两趟遍历完成，不用除法。',
    },
    '3': {
        approach: '滑动窗口 + 最近位置哈希',
        target: '求不含重复字符的最长子串长度。',
        brute: '枚举所有子串并检查是否有重复字符。',
        breakthrough: '窗口内保持字符唯一，遇到重复字符时左边界直接跳跃。',
        steps: [
            '维护 left 和 map[char]=最近索引。',
            '遍历 right，若 char 出现过且索引 >= left，则 left 跳到该索引+1。',
            '更新 map[char]=right，并更新最大长度 right-left+1。',
            '遍历结束得到答案。',
        ],
        time: 'O(n)',
        space: 'O(k)',
        pitfalls: ['left 只能右移不能回退。', '重复字符的旧索引若 < left 应忽略。'],
        pitch: '窗口始终保证“无重复”，右指针扩张，左指针按需跳跃，整体线性。',
    },
    '76': {
        approach: '滑动窗口最小覆盖',
        target: '找到包含 t 所有字符（含频次）的最短子串。',
        brute: '枚举全部子串并校验是否覆盖 t。',
        breakthrough: '先扩张到满足覆盖，再尽量收缩左边界找更短答案。',
        steps: [
            '统计 need 频次，维护窗口频次 window 与 missing 计数。',
            'right 扩张窗口；当字符满足需求时递减 missing。',
            'missing==0 时循环收缩 left，并持续更新最短长度。',
            '收缩过程中若破坏覆盖，退出收缩继续扩张。',
        ],
        time: 'O(n)',
        space: 'O(|字符集|)',
        pitfalls: ['频次条件是 >= 需求，不是仅出现过。', '更新最短答案要在收缩阶段进行。'],
        pitch: '这是典型“先满足再收缩”的窗口题，核心在频次统计与 missing 维护。',
    },
    '209': {
        approach: '滑动窗口最短长度',
        target: '找和至少为 target 的最短连续子数组长度。',
        brute: '枚举所有子数组并求和。',
        breakthrough: '数组为正数时，窗口和随 right 扩张单调增加，可双指针线性解。',
        steps: [
            '维护 left、sum 与最小长度 ans。',
            'right 每前进一步就把 nums[right] 加入 sum。',
            '当 sum >= target 时，不断右移 left 收缩并更新 ans。',
            '遍历结束，若 ans 未更新返回 0。',
        ],
        time: 'O(n)',
        space: 'O(1)',
        pitfalls: ['仅正数数组可用该单调窗口。', '收缩循环要用 while，不是 if。'],
        pitch: '因为元素全正，窗口和具有单调性，双指针每个元素最多进出一次。',
    },
    '42': {
        approach: '双指针接雨水',
        target: '计算柱形图可接雨水总量。',
        brute: '对每个位置找左右最大值再累加。',
        breakthrough: '谁低谁决定当前可接水高度，双指针可在线更新左右最大值。',
        steps: [
            'left 指向开头，right 指向末尾，维护 leftMax/rightMax。',
            '若 height[left] < height[right]，处理 left 位置并 left++。',
            '否则处理 right 位置并 right--。',
            '每步累加 max(0, leftMax-height[left]) 或对应右侧值。',
        ],
        time: 'O(n)',
        space: 'O(1)',
        pitfalls: ['移动短板一侧而不是长板。', '更新最大值与加水顺序要一致。'],
        pitch: '我用双指针和左右历史最高柱，单次扫描完成累计。',
    },
    '704': {
        approach: '标准二分搜索',
        target: '在有序数组中查找 target 下标。',
        brute: '线性扫描查找。',
        breakthrough: '有序数组可每次砍半。',
        steps: [
            '设置闭区间 [l, r] = [0, n-1]。',
            'while l <= r：mid = l + (r-l)//2。',
            '命中则返回 mid；若 nums[mid] < target，l=mid+1，否则 r=mid-1。',
            '循环结束未命中返回 -1。',
        ],
        time: 'O(log n)',
        space: 'O(1)',
        pitfalls: ['注意区间定义，闭区间就用 l<=r。', 'mid 计算避免溢出写法更稳健。'],
        pitch: '标准闭区间二分模板，比较中点后缩小到一半区间。',
    },
    '33': {
        approach: '旋转有序数组二分',
        target: '在旋转有序数组中查找 target 下标。',
        brute: '线性扫描。',
        breakthrough: '每轮总有一半区间有序，先判有序半边再判 target 是否在其中。',
        steps: [
            '二分取 mid，先判断 [l..mid] 或 [mid..r] 哪边有序。',
            '若左边有序且 target 在左边范围，收缩 r=mid-1，否则 l=mid+1。',
            '若右边有序且 target 在右边范围，收缩 l=mid+1，否则 r=mid-1。',
            '命中返回 mid，最后未命中返回 -1。',
        ],
        time: 'O(log n)',
        space: 'O(1)',
        pitfalls: ['区间比较要带等号边界。', '本题无重复值，逻辑更直接。'],
        pitch: '本质还是二分，只是先识别哪半边有序，再决定去向。',
    },
    '153': {
        approach: '旋转数组最小值二分',
        target: '找到旋转有序数组中的最小元素。',
        brute: '遍历取最小值。',
        breakthrough: '比较 nums[mid] 与 nums[right] 可判断最小值所在半区。',
        steps: [
            '初始化 l=0, r=n-1。',
            'while l<r：mid=(l+r)//2。',
            '若 nums[mid] > nums[r]，最小值在右侧，l=mid+1。',
            '否则最小值在左侧含 mid，r=mid。',
        ],
        time: 'O(log n)',
        space: 'O(1)',
        pitfalls: ['这里区间收缩是 r=mid，不是 mid-1。', 'l==r 时即最小值位置。'],
        pitch: '利用旋转后的分段有序性质，通过 mid 与右端比较持续缩区间。',
    },
    '875': {
        approach: '二分答案（最小可行值）',
        target: '找最小吃速 k，使总耗时 <= h。',
        brute: '从 1 到 max(piles) 逐个尝试速度。',
        breakthrough: '速度越快耗时越短，可行性关于 k 单调。',
        steps: [
            '设搜索区间 [1, maxPile]。',
            '定义 check(k)：累计 ceil(pile/k) 是否 <= h。',
            '二分 mid，若 check(mid) 可行则收缩右边找更小解。',
            '最终 l 即最小可行速度。',
        ],
        time: 'O(n log M)',
        space: 'O(1)',
        pitfalls: ['上取整要写成 (pile + k - 1) // k。', '这是找“最小可行”，可行时收右边。'],
        pitch: '典型二分答案题：把问题转成单调可行性判断。',
    },
    '20': {
        approach: '栈匹配括号',
        target: '判断括号字符串是否有效匹配。',
        brute: '反复删除合法对子直到不能删。',
        breakthrough: '遇左括号入栈，遇右括号必须匹配栈顶。',
        steps: [
            '建立映射 right->left。',
            '遍历字符：左括号入栈。',
            '遇右括号时检查栈顶是否对应左括号，不匹配立即 false。',
            '遍历结束栈为空则 true。',
        ],
        time: 'O(n)',
        space: 'O(n)',
        pitfalls: ['空栈遇右括号立即 false。', '最后必须栈空才合法。'],
        pitch: '这是典型后进先出匹配问题，栈是最自然的数据结构。',
    },
    '155': {
        approach: '双栈设计 MinStack',
        target: '支持 O(1) 的 push/pop/top/getMin。',
        brute: '每次 getMin 都遍历栈求最小。',
        breakthrough: '再维护一个最小栈，记录当前位置最小值。',
        steps: [
            '主栈存真实值，最小栈栈顶存当前最小值。',
            'push 时最小栈压入 min(x, minTop)。',
            'pop 时两个栈同时弹出。',
            'getMin 直接返回最小栈栈顶。',
        ],
        time: '各操作 O(1)',
        space: 'O(n)',
        pitfalls: ['两个栈长度必须同步。', '空栈操作要按题目约束处理。'],
        pitch: '把“历史最小值”也入栈保存，换空间拿到所有操作 O(1)。',
    },
    '739': {
        approach: '单调栈（下一个更大元素）',
        target: '返回每天距离下一个更高温度的天数。',
        brute: '每个位置向右扫描找第一个更大值。',
        breakthrough: '维护递减栈，当前温度更高时可一次性结算多个位置。',
        steps: [
            '栈里存“索引”，并保证对应温度递减。',
            '遍历 i，当前温度若大于栈顶温度，弹栈并写答案 i-top。',
            '重复直到栈空或不再更大，然后 i 入栈。',
            '遍历结束仍在栈内的位置答案为 0。',
        ],
        time: 'O(n)',
        space: 'O(n)',
        pitfalls: ['栈里存索引而不是温度值。', 'while 弹栈而不是单次 if。'],
        pitch: '用递减单调栈把“向右找更大”优化为均摊线性。',
    },
    '84': {
        approach: '单调栈求柱状图最大矩形',
        target: '求最大矩形面积。',
        brute: '枚举每个区间 [l,r] 计算最小高。',
        breakthrough: '以每根柱子为最矮柱时，它能扩展的左右边界可由单调栈确定。',
        steps: [
            '维护递增栈，栈内存索引。',
            '遍历到更矮柱时，持续弹栈并计算被弹出柱子的面积。',
            '宽度由“当前索引”和“新栈顶索引”确定。',
            '末尾补一个 0 高度触发剩余柱子结算。',
        ],
        time: 'O(n)',
        space: 'O(n)',
        pitfalls: ['宽度边界容易算错。', '常用哨兵技巧简化首尾处理。'],
        pitch: '把问题转成“每根柱子做最低高度时的最大宽度”，单调栈一次求完。',
    },
    '206': {
        approach: '链表三指针反转',
        target: '反转单链表并返回新头结点。',
        brute: '用数组保存节点再反向重连。',
        breakthrough: '原地修改 next 指针即可，维护 pre/cur/next。',
        steps: [
            'pre=null, cur=head。',
            '循环中先保存 next=cur.next。',
            '把 cur.next 指向 pre，再整体前移 pre=cur, cur=next。',
            '循环结束返回 pre。',
        ],
        time: 'O(n)',
        space: 'O(1)',
        pitfalls: ['先存 next 再改指针，否则链断。', '空链表和单节点要返回原值。'],
        pitch: '链表反转核心是指针重连顺序，三指针模板即可。',
    },
    '21': {
        approach: '哑节点 + 双指针归并',
        target: '合并两个有序链表。',
        brute: '取值到数组排序后重建链表。',
        breakthrough: '两个有序链表可像 merge 一样线性归并。',
        steps: [
            '建立 dummy 和 tail 指针。',
            '比较 l1/l2 当前节点值，把较小者接到 tail 后并前移。',
            '某一链结束后直接接上另一条剩余部分。',
            '返回 dummy.next。',
        ],
        time: 'O(m+n)',
        space: 'O(1)',
        pitfalls: ['不要丢失剩余链表。', '返回的是 dummy.next 不是 dummy。'],
        pitch: '这是链表版归并，双指针一次线性完成。',
    },
    '141': {
        approach: '快慢指针判环',
        target: '判断链表是否有环。',
        brute: '哈希集合记录访问过的节点地址。',
        breakthrough: '有环时快慢指针必相遇，无环则快指针先到空。',
        steps: [
            'slow=head, fast=head。',
            '循环中 slow 走一步，fast 走两步。',
            '若 fast 或 fast.next 为空则无环。',
            '若 slow===fast 则有环。',
        ],
        time: 'O(n)',
        space: 'O(1)',
        pitfalls: ['循环条件要先判 fast 和 fast.next。', '比较节点引用，不是值。'],
        pitch: 'Floyd 判圈：快慢指针相遇即有环，空间 O(1)。',
    },
    '142': {
        approach: 'Floyd 判圈 + 入口定位',
        target: '返回环的入口节点。',
        brute: '哈希集合记录首次重复节点。',
        breakthrough: '相遇后，一指针回头，二者同速再走会在入口相遇。',
        steps: [
            '先用快慢指针找相遇点；若无相遇返回 null。',
            '设 p1=head, p2=meeting。',
            'p1 与 p2 每次各走一步，首次相遇点就是入口。',
            '返回该节点。',
        ],
        time: 'O(n)',
        space: 'O(1)',
        pitfalls: ['先确认有环再做第二阶段。', '第二阶段速度都为 1。'],
        pitch: '先证明有环，再用数学关系把入口转化为“头指针与相遇点同速相遇”。',
    },
    '19': {
        approach: '双指针删倒数第 N 个',
        target: '删除链表倒数第 n 个节点。',
        brute: '先遍历求长度，再删第 len-n+1 个。',
        breakthrough: '让快指针先走 n 步，再同速走到尾，慢指针停在待删节点前驱。',
        steps: [
            '使用 dummy 指向 head，fast/slow 都从 dummy 出发。',
            'fast 先前进 n 步。',
            'fast 与 slow 同时前进直到 fast.next 为空。',
            '执行 slow.next = slow.next.next 并返回 dummy.next。',
        ],
        time: 'O(n)',
        space: 'O(1)',
        pitfalls: ['删除头结点时 dummy 很关键。', '快指针是先走 n 步不是 n-1。'],
        pitch: '通过固定间距双指针，一趟遍历定位待删节点前驱。',
    },
    '104': {
        approach: '树 DFS 求高度',
        target: '返回二叉树最大深度。',
        brute: '层序遍历计层数。',
        breakthrough: '树高可递归定义：1 + max(leftDepth, rightDepth)。',
        steps: [
            '递归终止：空节点深度 0。',
            '递归求左子树和右子树深度。',
            '返回 1 + max(left, right)。',
            '根节点返回值即答案。',
        ],
        time: 'O(n)',
        space: 'O(h)',
        pitfalls: ['空树应返回 0。', '递归深度最坏可到 O(n)。'],
        pitch: '直接按树高定义写后序 DFS，代码最短且清晰。',
    },
    '226': {
        approach: '递归交换左右子树',
        target: '翻转二叉树。',
        brute: '层序遍历后重建新树。',
        breakthrough: '对每个节点交换 left/right，再递归处理子树。',
        steps: [
            '递归基：节点为空返回 null。',
            '交换 root.left 与 root.right。',
            '递归翻转新的左、右子树。',
            '返回 root。',
        ],
        time: 'O(n)',
        space: 'O(h)',
        pitfalls: ['交换后再递归时要用交换后的指针。', '可写前序或后序，逻辑一致。'],
        pitch: '每个节点做同一个原子操作“交换左右”，天然递归。',
    },
    '102': {
        approach: '队列 BFS 分层',
        target: '返回二叉树层序遍历结果。',
        brute: 'DFS 记录节点深度后再按深度分组。',
        breakthrough: '队列天然按层推进，每轮固定处理当前层节点数。',
        steps: [
            '根节点入队。',
            '循环时先取当前队列长度 size，代表一层节点数。',
            '弹出 size 个节点组成当前层，并把子节点入队。',
            '把当前层数组加入答案。',
        ],
        time: 'O(n)',
        space: 'O(w)',
        pitfalls: ['每层 size 要提前固定。', '空树返回空数组。'],
        pitch: 'BFS 的“按层固定 size”是本题关键模板。',
    },
    '543': {
        approach: '后序 DFS 同时算深度和直径',
        target: '返回二叉树直径（任意两点最长路径边数）。',
        brute: '枚举每个节点作为拐点，重复计算子树高度。',
        breakthrough: '遍历每个节点时，leftDepth+rightDepth 就是经过该点的直径。',
        steps: [
            '定义 dfs(node) 返回该节点向下最大深度。',
            '递归得到 leftDepth 和 rightDepth。',
            '用 leftDepth + rightDepth 更新全局最大直径。',
            '返回 1 + max(leftDepth, rightDepth)。',
        ],
        time: 'O(n)',
        space: 'O(h)',
        pitfalls: ['直径按“边数”时空节点深度取 0。', '答案在全局变量，不一定经过根。'],
        pitch: '一次后序遍历把“深度”和“经过该点的路径长度”同时算出来。',
    },
    '94': {
        approach: '中序遍历（迭代或递归）',
        target: '返回二叉树中序序列。',
        brute: '无，遍历本身就是直接解法。',
        breakthrough: '中序顺序固定：左 -> 根 -> 右。',
        steps: [
            '递归法：先遍历左子树，再记录根，再遍历右子树。',
            '或迭代法：一路压左链，弹栈访问，再转向右子树。',
            '把访问值加入结果数组。',
            '最终返回结果。',
        ],
        time: 'O(n)',
        space: 'O(h)',
        pitfalls: ['迭代法循环条件是“栈不空或当前节点非空”。'],
        pitch: '中序模板题，推荐掌握迭代写法以应对面试追问。',
    },
    '98': {
        approach: 'BST 有效性区间约束',
        target: '判断二叉树是否为合法 BST。',
        brute: '中序遍历后检查是否严格递增。',
        breakthrough: '每个节点必须落在祖先传下来的 (low, high) 开区间。',
        steps: [
            'dfs(node, low, high) 表示当前节点允许范围。',
            '若 node.val 不在 (low, high) 直接 false。',
            '递归左子树区间变为 (low, node.val)。',
            '递归右子树区间变为 (node.val, high)。',
        ],
        time: 'O(n)',
        space: 'O(h)',
        pitfalls: ['必须严格小于/大于，不能等于。', '边界建议用 long/None 避免溢出。'],
        pitch: '我用上下界递归把 BST 定义直接编码，逻辑最严谨。',
    },
    '230': {
        approach: 'BST 中序第 k 小',
        target: '返回 BST 中第 k 小元素。',
        brute: '中序完整展开后取第 k-1 位。',
        breakthrough: 'BST 中序天然升序，遍历到第 k 个即可提前返回。',
        steps: [
            '做中序遍历（左根右）。',
            '每访问一个节点计数 +1。',
            '当计数等于 k 时记录并返回。',
            '可用迭代栈避免过深递归风险。',
        ],
        time: 'O(h + k)',
        space: 'O(h)',
        pitfalls: ['k 从 1 开始。', '可提前停止，不必完整遍历。'],
        pitch: '利用 BST 中序有序性，把“第 k 小”转为“中序第 k 个访问节点”。',
    },
    '236': {
        approach: '后序递归找最近公共祖先',
        target: '返回二叉树中 p、q 的最近公共祖先。',
        brute: '为每节点记录父指针后做祖先集合交集。',
        breakthrough: '后序返回“是否命中 p/q”，左右都命中时当前节点就是 LCA。',
        steps: [
            '递归基：node 为空返回 null；node 为 p 或 q 直接返回 node。',
            '递归求 left = dfs(node.left), right = dfs(node.right)。',
            '若 left 和 right 都非空，返回当前 node。',
            '否则返回非空一侧（向上传递命中节点）。',
        ],
        time: 'O(n)',
        space: 'O(h)',
        pitfalls: ['本题是普通二叉树不是 BST，不能用大小关系。'],
        pitch: '后序回溯时判断“左右子树是否各命中一个目标”，即可定位 LCA。',
    },
    '105': {
        approach: '前序 + 中序重建二叉树',
        target: '根据 preorder 和 inorder 重建原树。',
        brute: '每次在线性扫描中序找根位置并切片递归。',
        breakthrough: '前序首元素是根，中序中根左边是左子树，右边是右子树。',
        steps: [
            '预处理 map：inorder 值 -> 下标，加速定位根位置。',
            '递归函数参数使用索引区间，不要频繁切片。',
            '根据左子树节点数确定前序与中序的子区间边界。',
            '递归构建左右子树并返回根节点。',
        ],
        time: 'O(n)',
        space: 'O(n)',
        pitfalls: ['区间边界最容易写错。', '题目默认节点值唯一。'],
        pitch: '核心是“前序定根 + 中序分左右”，再用索引区间递归构建。',
    },
    '200': {
        approach: '网格 DFS/BFS 淹没岛屿',
        target: '统计二维网格中岛屿数量。',
        brute: '对每块陆地重复遍历连通块，且不做访问标记。',
        breakthrough: '遍历网格遇到陆地就计数，并立即把整个连通块标记已访问。',
        steps: [
            '双层循环扫描网格。',
            '遇到 "1" 时答案 +1，并启动 DFS/BFS。',
            '在搜索中把连通陆地改为 "0"（或 visited=true）。',
            '最终计数即岛屿数。',
        ],
        time: 'O(m*n)',
        space: 'O(m*n) 最坏递归栈/队列',
        pitfalls: ['记得做边界判断。', '访问标记要及时，避免重复计数。'],
        pitch: '本题本质是连通块计数，看到新陆地就淹没整块。',
    },
    '133': {
        approach: '图深拷贝 + 哈希映射',
        target: '克隆无向连通图并返回新起点。',
        brute: '尝试按值复制节点，忽略环和共享邻居关系。',
        breakthrough: '图有环，必须用 map(oldNode -> newNode) 去重并防无限递归。',
        steps: [
            '递归/队列遍历原图节点。',
            '若节点未克隆，先创建克隆节点并写入 map。',
            '遍历原节点邻居，把克隆邻居加入克隆节点邻接表。',
            '返回起始节点的克隆副本。',
        ],
        time: 'O(V+E)',
        space: 'O(V)',
        pitfalls: ['必须先放 map 再递归邻居，防止环死循环。'],
        pitch: '图复制的标准套路是“访问即建副本 + 哈希映射复用”。',
    },
    '207': {
        approach: '拓扑排序判环',
        target: '判断课程依赖图是否存在可完成的学习顺序。',
        brute: '回溯尝试所有排课顺序。',
        breakthrough: 'DAG 才有拓扑序；若拓扑处理节点数 < n，说明有环。',
        steps: [
            '建邻接表和入度数组。',
            '把入度 0 节点入队。',
            'BFS 弹出节点，减少其邻居入度，入度变 0 则入队。',
            '最终若处理节点数等于课程数则可完成。',
        ],
        time: 'O(V+E)',
        space: 'O(V+E)',
        pitfalls: ['边方向别写反：先修 -> 后续课程。'],
        pitch: '本题就是检测有向图是否有环，拓扑排序最直观。',
    },
    '210': {
        approach: '拓扑排序输出序列',
        target: '返回任意一个可行修课顺序。',
        brute: '回溯搜索所有可能顺序。',
        breakthrough: '沿用 Kahn 拓扑排序，把出队顺序作为答案。',
        steps: [
            '建图与入度。',
            '入度 0 课程入队。',
            '不断出队并写入结果，更新邻居入度。',
            '若结果长度 < n 返回空数组，否则返回结果。',
        ],
        time: 'O(V+E)',
        space: 'O(V+E)',
        pitfalls: ['有环时要返回空序列。'],
        pitch: '和 207 同源，区别是要把拓扑弹出顺序记录下来。',
    },
    '994': {
        approach: '多源 BFS 扩散',
        target: '返回所有橘子腐烂所需最少分钟数。',
        brute: '每分钟全图扫描一次做状态转移。',
        breakthrough: '所有初始腐烂点同时作为 BFS 起点，层数就是分钟数。',
        steps: [
            '把所有腐烂橘子坐标入队，并统计新鲜橘子数 fresh。',
            '按层 BFS：每层处理当前所有腐烂点，感染四邻新鲜橘子。',
            '每感染一次 fresh--；层结束 minutes++。',
            '最终 fresh==0 返回 minutes，否则返回 -1。',
        ],
        time: 'O(m*n)',
        space: 'O(m*n)',
        pitfalls: ['若初始 fresh=0，答案应为 0。', '分钟应按层递增。'],
        pitch: '把腐烂看成波前扩散，多源 BFS 的层数正好对应时间。',
    },
    '743': {
        approach: 'Dijkstra 最短路',
        target: '求从节点 k 出发让所有节点收到信号的最短时间。',
        brute: 'Bellman-Ford 做 V-1 轮松弛。',
        breakthrough: '边权非负时用 Dijkstra 更高效。',
        steps: [
            '建邻接表并初始化 dist，dist[k]=0。',
            '最小堆反复弹出当前最短距离节点。',
            '遍历出边做松弛，若变短则入堆。',
            '最终看 dist 最大值；若有 Infinity 返回 -1。',
        ],
        time: 'O((V+E) log V)',
        space: 'O(V+E)',
        pitfalls: ['堆里旧状态需跳过（d > dist[u]）。'],
        pitch: '这是标准单源最短路模板，非负权优先 Dijkstra。',
    },
    '684': {
        approach: '并查集找冗余边',
        target: '返回加入后首次形成环的边。',
        brute: '每加一条边都做一次图搜索判连通。',
        breakthrough: '若两端点已在同一集合，再连边必成环。',
        steps: [
            '初始化并查集 parent/rank。',
            '顺序遍历 edges。',
            '若 find(u) == find(v) 返回该边。',
            '否则 union(u, v) 合并集合。',
        ],
        time: 'O(n α(n))',
        space: 'O(n)',
        pitfalls: ['节点编号通常从 1 开始，数组开 n+1。'],
        pitch: '并查集在线维护连通性，首条“同集合连边”就是答案。',
    },
    '1584': {
        approach: '最小生成树（Prim/Kruskal）',
        target: '连接所有点使总代价最小（曼哈顿距离）。',
        brute: '枚举所有连接方式。',
        breakthrough: '题目本质是完全图 MST。',
        steps: [
            '选择 Prim：从任一点出发，每次扩展到未访问点的最小边。',
            '维护到生成树的最小代价 minDist[]。',
            '重复选最小未访问点并更新其它点代价。',
            '累计 n 次选点代价即答案。',
        ],
        time: 'O(n²)（Prim 朴素实现）',
        space: 'O(n)',
        pitfalls: ['完全图边数 O(n²)，不必显式建全部边也能做 Prim。'],
        pitch: '看到“连接全部点且总成本最小”优先联想到 MST。',
    },
    '1631': {
        approach: 'Dijkstra（最小化路径最大边权）',
        target: '最小化从左上到右下路径中的最大高度差。',
        brute: '二分答案 + BFS 或枚举路径。',
        breakthrough: '把路径代价定义为 max(经过边权)，可做 Dijkstra 变体。',
        steps: [
            'dist[x][y] 表示到该点的最小“最大边权”。',
            '堆顶弹出当前代价最小格子。',
            '转移到邻格时代价为 max(当前代价, 边权差)。',
            '到达终点时的代价即答案。',
        ],
        time: 'O(mn log(mn))',
        space: 'O(mn)',
        pitfalls: ['转移不是加法，是 max 运算。'],
        pitch: '把“effort”建模成最小化路径瓶颈，再套最短路框架。',
    },
    '70': {
        approach: '一维 DP（斐波那契）',
        target: '求爬到 n 阶的方法数。',
        brute: '纯递归枚举走法。',
        breakthrough: '到第 i 阶只可能来自 i-1 或 i-2。',
        steps: [
            '定义 dp[i] = 到达 i 阶的方法数。',
            '转移：dp[i] = dp[i-1] + dp[i-2]。',
            '初始化 dp[1]=1, dp[2]=2。',
            '返回 dp[n]，可用滚动变量降空间。',
        ],
        time: 'O(n)',
        space: 'O(1) 或 O(n)',
        pitfalls: ['n=1 的边界要单独处理。'],
        pitch: '标准斐波那契型 DP，写出状态和转移就结束。',
    },
    '198': {
        approach: '一维 DP（打家劫舍）',
        target: '不抢相邻房屋的最大收益。',
        brute: '回溯每间房选或不选。',
        breakthrough: '每间房只有“抢或不抢”两种决策：取 max(不抢当前, 抢当前+前前家)。',
        steps: [
            '定义 dp[i] 为前 i 间房最大收益。',
            '转移：dp[i] = max(dp[i-1], dp[i-2] + nums[i])。',
            '初始化前两项。',
            '顺序迭代得到答案。',
        ],
        time: 'O(n)',
        space: 'O(1) 或 O(n)',
        pitfalls: ['下标偏移与初始化要统一。'],
        pitch: '本题是典型“相邻互斥选择”DP。',
    },
    '213': {
        approach: '环形打家劫舍拆两段',
        target: '房屋成环，首尾不能同时抢。',
        brute: '回溯带首尾冲突判断。',
        breakthrough: '把环拆成两条线：要么抢 0..n-2，要么抢 1..n-1。',
        steps: [
            '若 n==1 直接返回 nums[0]。',
            '分别计算 robLinear(nums[0..n-2]) 与 robLinear(nums[1..n-1])。',
            'robLinear 用 198 的线性 DP。',
            '返回两者最大值。',
        ],
        time: 'O(n)',
        space: 'O(1)',
        pitfalls: ['n=1、n=2 边界别漏。'],
        pitch: '环形约束通过“二选一拆分”转回线性版本。',
    },
    '322': {
        approach: '完全背包最少硬币',
        target: '用最少硬币凑成 amount，凑不出返回 -1。',
        brute: 'DFS 枚举所有硬币组合。',
        breakthrough: '最优子结构：f[x] = min(f[x], f[x-coin]+1)。',
        steps: [
            '初始化 dp[0]=0，其余为 Infinity。',
            '遍历每个金额 x（或遍历硬币后金额），做转移。',
            '如果 dp[amount] 仍为 Infinity 则返回 -1。',
            '否则返回 dp[amount]。',
        ],
        time: 'O(amount * n)',
        space: 'O(amount)',
        pitfalls: ['初始化无穷大，避免未达状态参与转移。'],
        pitch: '这题是“最小值型完全背包”模板。',
    },
    '139': {
        approach: '字符串前缀 DP',
        target: '判断字符串能否由字典单词拼接而成。',
        brute: '回溯尝试所有切分点。',
        breakthrough: 'dp[i] 表示前 i 个字符可否拆分，转移由切分点 j 决定。',
        steps: [
            '把 wordDict 放进 set 提高查询效率。',
            'dp[0]=true，表示空串可拆分。',
            '对每个 i 枚举 j<i，若 dp[j] 且 s[j:i] 在字典中，则 dp[i]=true。',
            '返回 dp[n]。',
        ],
        time: 'O(n²)',
        space: 'O(n)',
        pitfalls: ['切片区间是 [j, i)。', '可剪枝限制最大单词长度。'],
        pitch: '关键是定义“前缀可拆分”状态，逐步扩展到全串。',
    },
    '300': {
        approach: 'LIS 贪心 + 二分',
        target: '求最长严格递增子序列长度。',
        brute: 'O(n²) DP：dp[i] 结尾 LIS。',
        breakthrough: 'tails[len] 维护长度 len+1 的最小结尾值，可二分更新。',
        steps: [
            '遍历每个数 x，在 tails 中二分找第一个 >=x 的位置 p。',
            '若 p 等于 tails 长度则追加 x，否则替换 tails[p]=x。',
            'tails 长度即 LIS 长度。',
            '替换不影响答案长度，只优化后续可扩展性。',
        ],
        time: 'O(n log n)',
        space: 'O(n)',
        pitfalls: ['严格递增用 lower_bound(>=x)。'],
        pitch: 'tails 不代表真实序列，但长度与最优答案一致。',
    },
    '1143': {
        approach: '二维 DP（LCS）',
        target: '求两个字符串最长公共子序列长度。',
        brute: '双指针回溯枚举所有子序列。',
        breakthrough: 'dp[i][j] 只依赖左、上、左上三个状态。',
        steps: [
            '定义 dp[i][j]：text1 前 i 个与 text2 前 j 个的 LCS 长度。',
            '若字符相等：dp[i][j]=dp[i-1][j-1]+1。',
            '否则：dp[i][j]=max(dp[i-1][j], dp[i][j-1])。',
            '返回 dp[m][n]。',
        ],
        time: 'O(mn)',
        space: 'O(mn)（可优化到 O(n)）',
        pitfalls: ['二维下标与字符串下标偏移 1。'],
        pitch: '经典二维 DP，转移方程固定且稳定。',
    },
    '72': {
        approach: '编辑距离二维 DP',
        target: '计算 word1 转成 word2 的最少操作数。',
        brute: '回溯尝试增删改所有操作路径。',
        breakthrough: '最后一步只可能是插入、删除、替换三者之一。',
        steps: [
            'dp[i][j] 表示 word1 前 i 个转成 word2 前 j 个的最小操作数。',
            '边界：dp[i][0]=i, dp[0][j]=j。',
            '若字符相等，dp[i][j]=dp[i-1][j-1]；否则取三操作最小+1。',
            '返回 dp[m][n]。',
        ],
        time: 'O(mn)',
        space: 'O(mn)',
        pitfalls: ['三种操作对应状态别写反。'],
        pitch: '把“最后一步操作”分类即可得到标准转移。',
    },
    '516': {
        approach: '区间 DP（最长回文子序列）',
        target: '求字符串最长回文子序列长度。',
        brute: '枚举所有子序列并判回文。',
        breakthrough: '看区间两端字符：相等就扩 2，不等取去掉一端的最大值。',
        steps: [
            '定义 dp[i][j] 为 s[i..j] 的 LPS 长度。',
            '初始化 dp[i][i]=1。',
            'i 从后往前，j 从 i+1 往后枚举。',
            '若 s[i]==s[j]，dp[i][j]=dp[i+1][j-1]+2，否则取 max(dp[i+1][j], dp[i][j-1])。',
        ],
        time: 'O(n²)',
        space: 'O(n²)',
        pitfalls: ['区间 DP 的遍历顺序必须保证子问题先算。'],
        pitch: '本题是标准“左右端点决策”的区间 DP。',
    },
    '46': {
        approach: '回溯全排列',
        target: '返回数组所有排列。',
        brute: '调用库函数生成全排列。',
        breakthrough: '每层固定一个位置，尝试所有未使用数字。',
        steps: [
            '维护 path 和 used[]。',
            '递归层数等于 path 长度；到 n 时收集答案。',
            '遍历候选数字，未使用则加入 path 并递归。',
            '回溯时撤销选择（pop + used=false）。',
        ],
        time: 'O(n * n!)',
        space: 'O(n)',
        pitfalls: ['回溯撤销必须成对。'],
        pitch: '排列题模板：路径 + used + 选择/撤销。',
    },
    '78': {
        approach: '回溯子集（选/不选）',
        target: '返回所有子集（幂集）。',
        brute: '按位枚举 0..(1<<n)-1。',
        breakthrough: '每个元素都有“选或不选”两种决策。',
        steps: [
            '回溯函数参数为当前索引 start。',
            '每到一个节点先把当前 path 加入答案。',
            '从 start 开始枚举后续元素，依次选择并递归。',
            '递归返回后撤销选择继续下一个分支。',
        ],
        time: 'O(n * 2^n)',
        space: 'O(n)',
        pitfalls: ['结果是所有中间状态，不只是叶子。'],
        pitch: '子集题是回溯入门：每层决定后续元素是否加入。',
    },
    '39': {
        approach: '回溯组合总和（可重复选）',
        target: '找出和为 target 的组合，元素可重复使用。',
        brute: '枚举所有多重组合后过滤。',
        breakthrough: '排序后 DFS，可通过索引控制是否允许重复使用当前元素。',
        steps: [
            '先对 candidates 排序，便于剪枝。',
            'dfs(start, remain)：remain 为剩余目标值。',
            '循环 i 从 start 开始，选择 candidates[i] 后递归 dfs(i, remain-val)。',
            'remain==0 收集答案；remain<0 立即回退。',
        ],
        time: '与解空间相关（指数级）',
        space: 'O(target) 递归深度',
        pitfalls: ['可重复使用时递归传 i，不是 i+1。'],
        pitch: '本题关键是“同层去重”和“可重复选择”索引控制。',
    },
    '22': {
        approach: '回溯生成有效括号',
        target: '生成 n 对括号的所有有效组合。',
        brute: '生成所有 2^(2n) 串再过滤合法性。',
        breakthrough: '构造时就保持前缀合法：右括号数量不能超过左括号。',
        steps: [
            '回溯参数 leftUsed/rightUsed。',
            '若 leftUsed < n，可放 "("。',
            '若 rightUsed < leftUsed，可放 ")"。',
            '当长度达到 2n 时收集结果。',
        ],
        time: 'Catalan 数量级',
        space: 'O(n)',
        pitfalls: ['rightUsed 不能超过 leftUsed。'],
        pitch: '用约束剪枝把非法前缀提前砍掉，效率远高于暴力生成。',
    },
    '79': {
        approach: '网格回溯 DFS',
        target: '判断网格中是否存在给定单词路径。',
        brute: '从每格出发暴力 DFS 不做访问控制。',
        breakthrough: 'DFS 过程中必须标记访问并在回溯时恢复。',
        steps: [
            '遍历所有起点 cell，若字符匹配首字母则尝试 DFS。',
            'dfs(x,y,k) 匹配 word[k]，向四邻继续匹配 k+1。',
            '进入前标记 visited，退出时撤销标记。',
            '任一路径匹配完全部字符即返回 true。',
        ],
        time: 'O(mn * 4^L)',
        space: 'O(L)',
        pitfalls: ['回溯必须恢复现场。', '越界和字符不匹配要先剪枝。'],
        pitch: '典型网格回溯：状态是坐标 + 已匹配长度。',
    },
    '215': {
        approach: '大小为 k 的小根堆',
        target: '返回数组第 k 大元素。',
        brute: '排序后取第 n-k 位。',
        breakthrough: '维护前 k 大元素集合，堆顶就是第 k 大。',
        steps: [
            '遍历数组元素 x。',
            '先入小根堆；若堆大小 > k，则弹出最小值。',
            '遍历结束堆顶即第 k 大。',
            '也可用快速选择实现平均线性。',
        ],
        time: 'O(n log k)',
        space: 'O(k)',
        pitfalls: ['别用大根堆存全部元素，复杂度更差。'],
        pitch: '用小根堆保留“前 k 大”，堆顶正好是答案。',
    },
    '347': {
        approach: '频次统计 + TopK 堆',
        target: '返回出现频率最高的 k 个元素。',
        brute: '统计后按频次全量排序。',
        breakthrough: '频次 map 后，用大小 k 小根堆维护 top k。',
        steps: [
            '先统计每个数字频次。',
            '遍历 (num, freq) 入小根堆（按 freq）。',
            '堆大小超过 k 就弹出最小频次。',
            '最终堆内元素即 top k。',
        ],
        time: 'O(n log k)',
        space: 'O(n)',
        pitfalls: ['堆比较键应是频次。'],
        pitch: '先计数，再做 TopK，是最稳的组合套路。',
    },
    '295': {
        approach: '双堆维护数据流中位数',
        target: '支持动态插入并快速查询中位数。',
        brute: '每次插入后重新排序。',
        breakthrough: '左半用大根堆，右半用小根堆，并维持平衡。',
        steps: [
            '插入新数时先进入某一堆，再通过弹出转移保持有序关系。',
            '保证左堆大小 >= 右堆，且差不超过 1。',
            '若总数奇数，中位数是左堆顶；偶数是两堆顶平均。',
            '每次 addNum 复杂度 O(log n)。',
        ],
        time: 'add O(log n), find O(1)',
        space: 'O(n)',
        pitfalls: ['堆平衡和大小关系都要维护。'],
        pitch: '双堆把序列切成左右两半，中位数永远在堆顶位置。',
    },
    '146': {
        approach: '哈希表 + 双向链表 LRU',
        target: '实现 O(1) 的 get/put 并淘汰最近最少使用项。',
        brute: '数组模拟缓存并线性移动元素。',
        breakthrough: '哈希表定位节点，双向链表维护最近使用顺序。',
        steps: [
            '链表头表示最近使用，尾表示最久未使用。',
            'get 命中后把节点移动到头部。',
            'put 命中则更新值并移头；未命中则新建节点插头。',
            '容量超限时弹出尾节点并从哈希表删除。',
        ],
        time: 'O(1)',
        space: 'O(capacity)',
        pitfalls: ['链表操作要封装 remove/addToHead。', '别忘记淘汰时同步删 map。'],
        pitch: '这题是经典设计题：哈希负责快查，链表负责顺序。',
    },
    '11': {
        approach: '双指针容器盛水',
        target: '选两条线使盛水面积最大。',
        brute: '枚举所有两线组合计算面积。',
        breakthrough: '面积由短板决定，移动长板不会变好，只移动短板才有机会。',
        steps: [
            'left=0, right=n-1，计算当前面积。',
            '更新全局最大面积。',
            '若左高 < 右高，left++，否则 right--。',
            '直到 left>=right 结束。',
        ],
        time: 'O(n)',
        space: 'O(1)',
        pitfalls: ['移动短板是关键证明点。'],
        pitch: '双指针夹逼，利用短板效应把 O(n²) 降到 O(n)。',
    },
    '15': {
        approach: '排序 + 固定一位 + 双指针',
        target: '找所有和为 0 的不重复三元组。',
        brute: '三重循环枚举三元组。',
        breakthrough: '排序后可用双指针找两数和，并通过跳重去重。',
        steps: [
            '先排序数组。',
            '枚举 i 作为第一个数，若 nums[i] 与前一位相同则跳过。',
            '在区间 [i+1, n-1] 用双指针找和为 -nums[i] 的配对。',
            '命中后左右指针都跳过重复值。',
        ],
        time: 'O(n²)',
        space: 'O(1) 或排序开销',
        pitfalls: ['去重要做三处：i、left、right。'],
        pitch: '固定一个数后转成 two-sum，排序+双指针是标配解法。',
    },
    '121': {
        approach: '一次遍历维护最低买入价',
        target: '一次交易下最大利润。',
        brute: '枚举买卖日组合。',
        breakthrough: '卖出日固定时，最优买入价是之前最小价格。',
        steps: [
            '遍历价格，维护 minPrice（历史最低）。',
            '当前利润 = price - minPrice，更新最大利润。',
            '同时更新 minPrice = min(minPrice, price)。',
            '遍历结束返回最大利润。',
        ],
        time: 'O(n)',
        space: 'O(1)',
        pitfalls: ['利润不能为负，初始答案设 0。'],
        pitch: '把问题变成“当前价减去历史最低价”的在线最大值。',
    },
    '56': {
        approach: '区间排序后合并',
        target: '合并所有重叠区间。',
        brute: '反复扫描并合并直到无变化。',
        breakthrough: '先按起点排序，重叠关系只需与“当前合并区间”比较。',
        steps: [
            '按区间起点升序排序。',
            '初始化 current 为第一个区间。',
            '遍历后续区间：若重叠则扩展 current.end；不重叠则输出 current 并重置。',
            '最后把 current 加入答案。',
        ],
        time: 'O(n log n)',
        space: 'O(n)（结果不计可视为 O(1) 额外）',
        pitfalls: ['重叠条件是 next.start <= current.end。'],
        pitch: '排序把“全局重叠”降成“相邻比较”，合并逻辑就很直接。',
    },
}

const MOCK_GUIDES = {
    'mock-60min': {
        approach: '60 分钟模拟面试流程',
        target: '在限定时间内完成“读题 -> 思路 -> 编码 -> 自测 -> 复盘”。',
        brute: '直接做题不控时，容易写不完或讲不清。',
        breakthrough: '把整场拆成时间片并强制执行。',
        steps: [
            '0-5 分钟：读题、确认输入输出、口述边界。',
            '5-15 分钟：先说暴力，再给最优思路与复杂度。',
            '15-40 分钟：编码主解，先过主流程后补边界。',
            '40-55 分钟：手工跑样例 + 极端用例。',
            '55-60 分钟：复盘失误点并记录二刷动作。',
        ],
        time: '整场 60 分钟',
        space: 'N/A',
        pitfalls: ['卡住超过 5 分钟要立即降级到可运行版本。', '别只写代码不讲思路。'],
        pitch: '我会先口述解法和复杂度，再编码并用 2-3 个用例验证正确性。',
    },
    'mock-60min-2': {
        approach: '60 分钟二次模拟（压力版）',
        target: '提升在压力下的稳定输出能力。',
        brute: '重复同样节奏但不做复盘，提升有限。',
        breakthrough: '加入“中途打断追问”训练，逼近真实面试。',
        steps: [
            '前 10 分钟：题意澄清 + 数据范围 + 方案选择。',
            '中 30 分钟：编码并持续口述不变量与边界。',
            '后 15 分钟：复杂度、正确性证明、可优化点。',
            '最后 5 分钟：记录一条“下次避免同类错误”的行动项。',
        ],
        time: '整场 60 分钟',
        space: 'N/A',
        pitfalls: ['追问时先答结论再展开细节。'],
        pitch: '我会把题目拆成可验证步骤，并在编码时同步解释关键决策。',
    },
    'mock-90min': {
        approach: '90 分钟综合模拟',
        target: '模拟完整面试轮：多题切换 + 追问 + 总结。',
        brute: '只做单题，不练切题和上下文切换。',
        breakthrough: '按真实流程演练“开场沟通 -> 题解 -> 深挖 -> 复盘”。',
        steps: [
            '0-10 分钟：热身题，重在沟通和建模速度。',
            '10-60 分钟：主问题深挖，至少覆盖一轮优化或改写。',
            '60-80 分钟：追问（复杂度、边界、替代方案）。',
            '80-90 分钟：总结亮点与风险，形成下轮训练清单。',
        ],
        time: '整场 90 分钟',
        space: 'N/A',
        pitfalls: ['切题时先重述目标，避免思路断层。'],
        pitch: '我会优先保证沟通和可验证过程，再追求最优实现。',
    },
}

function makeGenericGuide(task, dayTheme) {
    return {
        approach: `${dayTheme || '该题型'}通用解题框架`,
        target: `完成 ${task.title} 的核心要求并给出可通过样例的实现。`,
        brute: '先写一个正确但可能较慢的基线方案，确保题意理解无误。',
        breakthrough: '分析是否存在单调性、可复用状态、或可替换的数据结构来降复杂度。',
        steps: [
            '明确输入规模与约束，先确认暴力上界。',
            '识别题型（哈希/双指针/DP/图等）并选择模板。',
            '写出状态定义与转移/更新规则。',
            '用边界用例验证后再做常数优化。',
        ],
        time: '按具体题型而定',
        space: '按具体题型而定',
        pitfalls: ['不要跳过边界测试。', '先保证正确性，再做优化。'],
        pitch: '先给正确方案，再说明如何利用题目结构把复杂度降下来。',
    }
}

function normalizeGuide(task, dayTheme, guide) {
    const thinkingFlow = [
        `先明确目标：${guide.target}`,
        `先给出可行但较慢的起点：${guide.brute}`,
        `找到性能突破点：${guide.breakthrough}`,
        `最终采用：${guide.approach}`,
        `按“最优解分步骤”落地，并在边界用例上验证。`,
        `复杂度结论：时间 ${guide.time}，空间 ${guide.space}。`,
    ]
    const isMock = task.id.startsWith('mock-')
    return {
        title: `${task.id}. ${task.title}`,
        dayTheme: dayTheme || '综合',
        approach: guide.approach,
        target: guide.target,
        brute: guide.brute,
        breakthrough: guide.breakthrough,
        steps: guide.steps,
        time: guide.time,
        space: guide.space,
        pitfalls: guide.pitfalls,
        pitch: guide.pitch,
        thinkingFlow,
        hasPythonCode: !isMock,
        pythonCode: isMock ? '' : getProblemPythonCode(task),
    }
}

export function getProblemGuide(task, dayTheme = '') {
    if (!task || !task.id) return null
    if (task.id.startsWith('mock-')) {
        const mockGuide = MOCK_GUIDES[task.id] || makeGenericGuide(task, dayTheme)
        return normalizeGuide(task, dayTheme, mockGuide)
    }
    const guide = GUIDES[task.id] || makeGenericGuide(task, dayTheme)
    return normalizeGuide(task, dayTheme, guide)
}
